<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Jacob A. Long" />

<meta name="date" content="2023-02-08" />

<title>Reshaping panel data with long_panel() and widen_panel()</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Reshaping panel data with
<code>long_panel()</code> and <code>widen_panel()</code></h1>
<h4 class="author">Jacob A. Long</h4>
<h4 class="date">2023-02-08</h4>



<p>One of the initial challenges a data analyst is likely to face with
panel data is getting it into a format suitable for analysis. Most
regression analyses for panel data require the data to be in
<strong>long</strong> format. That means there is a row for each entity
(e.g., person) at each time point. If I conducted a 3-wave panel survey
of 300 people, each of whom responded to all 3 waves, the long format of
these data would have 900 rows (300 respondents x 3 waves).</p>
<p>For example, the following is how long data look, where
<code>id</code> is the identifier for each entity, <code>wave</code> is
the indicator of the time point, and <code>Q1</code>/<code>Q2</code> are
measures repeated at each time point.</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="right">wave</th>
<th align="right">Q1</th>
<th align="right">Q2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.0</td>
<td align="right">5.0</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="right">2</td>
<td align="right">1.5</td>
<td align="right">7.5</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="right">3</td>
<td align="right">2.0</td>
<td align="right">10.0</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">1</td>
<td align="right">5.0</td>
<td align="right">14.0</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="right">2</td>
<td align="right">4.0</td>
<td align="right">10.5</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">3</td>
<td align="right">3.0</td>
<td align="right">7.0</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">1</td>
<td align="right">15.0</td>
<td align="right">8.0</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="right">2</td>
<td align="right">12.0</td>
<td align="right">12.0</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">3</td>
<td align="right">9.0</td>
<td align="right">16.0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Wide</strong> data, on the other hand, have only one row per
entity and a separate column for each measure and time point. The same
data above in wide format look like this:</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="right">Q1_W1</th>
<th align="right">Q1_W2</th>
<th align="right">Q1_W3</th>
<th align="right">Q2_W1</th>
<th align="right">Q2_W2</th>
<th align="right">Q2_W3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.5</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">7.5</td>
<td align="right">10</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">5</td>
<td align="right">4.0</td>
<td align="right">3</td>
<td align="right">14</td>
<td align="right">10.5</td>
<td align="right">7</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">15</td>
<td align="right">12.0</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">12.0</td>
<td align="right">16</td>
</tr>
</tbody>
</table>
</div>
<p>Here you differentiate between waves by looking at the column name,
which in this case end in “_W” and then the wave indicator. Some
analyses prefer the data in this format, like structural equation
models.</p>
<p><code>panelr</code> considers the native format of panel data to be
<em>long</em> and provides the <code>panel_data</code> class to keep
your data tidy in the long format. Of course, sometimes your raw data
aren’t in long format and need to be “reshaped” from wide to long. In
other cases, you have long format data but need to get it into wide
format for some reason or another. <code>panelr</code> provides tools to
help with these situations.</p>
<p>There are some other tools, including ones that <code>panelr</code>
uses internally, that can manage these situations. However, they tend to
be some combination of confusing, inflexible, or too general to be
easily used for these purposes by non-experts.</p>
<div id="from-wide-to-long" class="section level2">
<h2>From wide to long</h2>
<p>In my experience, survey contractors (i.e., the people you pay to
carry out panel surveys) like to provide the data in wide format. As a
general rule, the conversion of data from wide to long is much more
difficult than the inverse. When preparing to reshape data from wide to
long format, you’ll need to answer some questions relating to how the
column/variable names distinguish the variable name from the time
indicator:</p>
<ul>
<li>What are the time indicators: numbers, letters, something else?</li>
<li>Are the time labels at the beginning or end of the column name?</li>
<li>Are there prefixes or suffixes surrounding the time indicator (e.g.,
a name like <code>W1_variable</code> has both prefix (<code>W</code>)
and suffix (<code>_</code>)).</li>
</ul>
<p>One key assumption is that variables labeled with a pattern such as
<code>Q1_W1</code>, <code>Q1_W2</code>, and so on refer to the <em>same
measure</em> at different times. I’ve encountered datasets in which
<code>Q1</code> might refer to a different measure at each time point
and this is not a problem that can be handled in an automated way.</p>
<p>With that warning out of the way, let’s look at a couple
examples.</p>
<div id="wave-indicators-at-the-end-of-variable-names" class="section level3">
<h3>Wave indicators at the end of variable names</h3>
<p>Let’s return to the wide data we looked at earlier.</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="right">Q1_W1</th>
<th align="right">Q1_W2</th>
<th align="right">Q1_W3</th>
<th align="right">Q2_W1</th>
<th align="right">Q2_W2</th>
<th align="right">Q2_W3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.5</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">7.5</td>
<td align="right">10</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">5</td>
<td align="right">4.0</td>
<td align="right">3</td>
<td align="right">14</td>
<td align="right">10.5</td>
<td align="right">7</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">15</td>
<td align="right">12.0</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">12.0</td>
<td align="right">16</td>
</tr>
</tbody>
</table>
</div>
<p>Here we can see that the time indicators are at the <em>end</em> of
the variable names (<code>_W1</code>), time indicators of 1, 2, and 3,
and a <em>prefix</em> of <code>_W</code>. With that in mind, we can use
<code>long_panel()</code> to convert the data to long format.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">long_panel</span>(wide, <span class="at">prefix =</span> <span class="st">&quot;_W&quot;</span>, <span class="at">begin =</span> <span class="dv">1</span>, <span class="at">end =</span> <span class="dv">3</span>, <span class="at">label_location =</span> <span class="st">&quot;end&quot;</span>)</span></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="right">wave</th>
<th align="right">Q1</th>
<th align="right">Q2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.0</td>
<td align="right">5.0</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="right">2</td>
<td align="right">1.5</td>
<td align="right">7.5</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="right">3</td>
<td align="right">2.0</td>
<td align="right">10.0</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">1</td>
<td align="right">5.0</td>
<td align="right">14.0</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="right">2</td>
<td align="right">4.0</td>
<td align="right">10.5</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">3</td>
<td align="right">3.0</td>
<td align="right">7.0</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">1</td>
<td align="right">15.0</td>
<td align="right">8.0</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="right">2</td>
<td align="right">12.0</td>
<td align="right">12.0</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">3</td>
<td align="right">9.0</td>
<td align="right">16.0</td>
</tr>
</tbody>
</table>
</div>
<p>Perfect! The first argument, <code>w</code>, was the wide data.
<code>prefix</code> is self-explanatory. <code>begin</code> and
<code>end</code> refer to the range of the time indicators, since they
are consecutive. You can instead use <code>periods = c(1, 2, 3)</code>
if you prefer. That’s especially true if you have non-consecutive time
indicators like a biannual survey that uses the year as an indicator,
like <code>periods = c(1990, 1992, 1994)</code>.</p>
</div>
<div id="comparing-with-base-r" class="section level3">
<h3>Comparing with base R</h3>
<p>I should note that base R has a function, <code>reshape()</code> that
can work in this situation without making you pull your hair out too
much:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">reshape</span>(<span class="fu">as.data.frame</span>(wide), <span class="at">sep =</span> <span class="st">&quot;_W&quot;</span>, <span class="at">times =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>), <span class="at">direction =</span> <span class="st">&quot;long&quot;</span>,</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>        <span class="at">varying =</span> <span class="fu">c</span>(<span class="st">&quot;Q1_W1&quot;</span>, <span class="st">&quot;Q1_W2&quot;</span>, <span class="st">&quot;Q1_W3&quot;</span>, <span class="st">&quot;Q2_W1&quot;</span>, <span class="st">&quot;Q2_W2&quot;</span>, <span class="st">&quot;Q2_W3&quot;</span>))</span></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">id</th>
<th align="right">time</th>
<th align="right">Q1</th>
<th align="right">Q2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1.1</td>
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.0</td>
<td align="right">5.0</td>
</tr>
<tr class="even">
<td align="left">2.1</td>
<td align="left">2</td>
<td align="right">1</td>
<td align="right">5.0</td>
<td align="right">14.0</td>
</tr>
<tr class="odd">
<td align="left">3.1</td>
<td align="left">3</td>
<td align="right">1</td>
<td align="right">15.0</td>
<td align="right">8.0</td>
</tr>
<tr class="even">
<td align="left">1.2</td>
<td align="left">1</td>
<td align="right">2</td>
<td align="right">1.5</td>
<td align="right">7.5</td>
</tr>
<tr class="odd">
<td align="left">2.2</td>
<td align="left">2</td>
<td align="right">2</td>
<td align="right">4.0</td>
<td align="right">10.5</td>
</tr>
<tr class="even">
<td align="left">3.2</td>
<td align="left">3</td>
<td align="right">2</td>
<td align="right">12.0</td>
<td align="right">12.0</td>
</tr>
<tr class="odd">
<td align="left">1.3</td>
<td align="left">1</td>
<td align="right">3</td>
<td align="right">2.0</td>
<td align="right">10.0</td>
</tr>
<tr class="even">
<td align="left">2.3</td>
<td align="left">2</td>
<td align="right">3</td>
<td align="right">3.0</td>
<td align="right">7.0</td>
</tr>
<tr class="odd">
<td align="left">3.3</td>
<td align="left">3</td>
<td align="right">3</td>
<td align="right">9.0</td>
<td align="right">16.0</td>
</tr>
</tbody>
</table>
</div>
<p>You can see how frustrating that could be if you had many more
variables — it wouldn’t be unusual to have hundreds of columns in the
wide format, not all of which would be variables that vary over time
(e.g., race). Truth be told, <code>long_panel()</code> uses
<code>reshape()</code> internally, but only after a lot of processing.
Other options include the <code>reshape2</code> and <code>tidyr</code>
packages, but they are not purpose-built for the panel setting and
therefore can have a learning curve to avoid having data that end up a
bit <em>too</em> long.</p>
</div>
<div id="a-more-challenging-example" class="section level3">
<h3>A more challenging example</h3>
<p>Here’s a wide dataset with what is usually a trickier format to
handle due to limitations of <code>reshape()</code>.</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="right">WA_Q1</th>
<th align="right">WB_Q1</th>
<th align="right">WC_Q1</th>
<th align="right">WA_Q2</th>
<th align="right">WC_Q2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">1.5</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">10</td>
</tr>
<tr class="even">
<td align="right">5</td>
<td align="right">4.0</td>
<td align="right">3</td>
<td align="right">14</td>
<td align="right">7</td>
</tr>
<tr class="odd">
<td align="right">15</td>
<td align="right">12.0</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">16</td>
</tr>
</tbody>
</table>
</div>
<p>Key characteristics:</p>
<ul>
<li>Wave indicators are at the <em>beginning</em> of the variable
names.</li>
<li>The time indicators are <em>letters</em>, from A to C.</li>
<li>There is a prefix (<code>W</code>) and suffix (<code>_</code>).</li>
</ul>
<p>While you don’t have to recognize this to use the function properly,
notice that in this case <code>Q2</code> was only measured at times A
and C. This can add considerable difficulty to when trying to reshape
data “by hand.”</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">long_panel</span>(wide, <span class="at">prefix =</span> <span class="st">&quot;W&quot;</span>, <span class="at">suffix =</span> <span class="st">&quot;_&quot;</span>, <span class="at">label_location =</span> <span class="st">&quot;beginning&quot;</span>,</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>           <span class="at">begin =</span> <span class="st">&quot;A&quot;</span>, <span class="at">end =</span> <span class="st">&quot;C&quot;</span>)</span></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">wave</th>
<th align="right">Q1</th>
<th align="right">Q2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">A</td>
<td align="right">1.0</td>
<td align="right">5</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">B</td>
<td align="right">1.5</td>
<td align="right">NA</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">C</td>
<td align="right">2.0</td>
<td align="right">10</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">A</td>
<td align="right">5.0</td>
<td align="right">14</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">B</td>
<td align="right">4.0</td>
<td align="right">NA</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">C</td>
<td align="right">3.0</td>
<td align="right">7</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">A</td>
<td align="right">15.0</td>
<td align="right">8</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">B</td>
<td align="right">12.0</td>
<td align="right">NA</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">C</td>
<td align="right">9.0</td>
<td align="right">16</td>
</tr>
</tbody>
</table>
</div>
<p>Just what we were looking for. Note that <code>panel_data</code>
objects must have an ordered wave variable, but <code>long_data()</code>
understands how to order letters and handles that for you. The
missingness in <code>Q2</code> is by design, since it wasn’t measured in
wave B.</p>
<p>Another issue that can come up is the treatment of constants — that
is, variables that do not change over time. The best wide data should
come labeled in a way that makes it clear the constants are constants.
For instance, a variable signifying race wouldn’t be called
<code>race_W1</code>, but instead just <code>race</code>.
<code>long_panel()</code> automatically checks your data for variables
that are labeled as if they vary over time but actually do not.</p>
<p>For instance, data that start by looking like this:</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="right">id</th>
<th align="right">Q1_W1</th>
<th align="right">Q1_W2</th>
<th align="right">Q1_W3</th>
<th align="left">race_W1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1.5</td>
<td align="right">2</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">4</td>
<td align="right">3.0</td>
<td align="right">2</td>
<td align="left">black</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">15</td>
<td align="right">12.0</td>
<td align="right">9</td>
<td align="left">white</td>
</tr>
</tbody>
</table>
</div>
<p>Can easily end up shaped like this:</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="right">id</th>
<th align="right">wave</th>
<th align="left">race</th>
<th align="right">Q1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">1</td>
<td align="left">white</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">2</td>
<td align="left">NA</td>
<td align="right">1.5</td>
</tr>
<tr class="odd">
<td align="right">1</td>
<td align="right">3</td>
<td align="left">NA</td>
<td align="right">2.0</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">1</td>
<td align="left">black</td>
<td align="right">4.0</td>
</tr>
<tr class="odd">
<td align="right">2</td>
<td align="right">2</td>
<td align="left">NA</td>
<td align="right">3.0</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">3</td>
<td align="left">NA</td>
<td align="right">2.0</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">1</td>
<td align="left">white</td>
<td align="right">15.0</td>
</tr>
<tr class="even">
<td align="right">3</td>
<td align="right">2</td>
<td align="left">NA</td>
<td align="right">12.0</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">3</td>
<td align="left">NA</td>
<td align="right">9.0</td>
</tr>
</tbody>
</table>
</div>
<p>But obviously just because the wide data marked <code>race</code>
with a wave label, that doesn’t mean it was unknown in the other waves.
You’ll get the right result with <code>long_panel()</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">long_panel</span>(wide, <span class="at">prefix =</span> <span class="st">&quot;_W&quot;</span>, <span class="at">label_location =</span> <span class="st">&quot;end&quot;</span>, <span class="at">begin =</span> <span class="dv">1</span>, <span class="at">end =</span> <span class="dv">3</span>)</span></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="right">wave</th>
<th align="right">Q1</th>
<th align="left">race</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.0</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="right">2</td>
<td align="right">1.5</td>
<td align="left">white</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="right">3</td>
<td align="right">2.0</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">1</td>
<td align="right">4.0</td>
<td align="left">black</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="right">2</td>
<td align="right">3.0</td>
<td align="left">black</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">3</td>
<td align="right">2.0</td>
<td align="left">black</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">1</td>
<td align="right">15.0</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="right">2</td>
<td align="right">12.0</td>
<td align="left">white</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">3</td>
<td align="right">9.0</td>
<td align="left">white</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="other-details" class="section level3">
<h3>Other details</h3>
<p>If you have an ID variable in the wide data, you can pass the name of
that variable to <code>long_panel()</code> with the <code>id</code>
argument, which is <code>&quot;id&quot;</code> by default. If there is no variable
with the name you give to <code>id</code>, one will be created. You can
also choose the name of the wave variable via <code>wave</code>, which
is <code>&quot;wave&quot;</code> by default.</p>
<p>You can also choose not to have the output of
<code>long_panel()</code> be a <code>panel_data</code> object by setting
<code>as_panel_data</code> to <code>FALSE</code>.</p>
</div>
<div id="advanced-options" class="section level3">
<h3>Advanced options</h3>
<p>There are some other options available to you for tougher cases. For
instance, when <code>use.regex</code> is <code>TRUE</code>, the
arguments for <code>prefix</code> and <code>suffix</code> are treated as
regular expressions for more complicated patterns.</p>
<p>Internally, time-varying variables are detected by the presence of
<code>prefix</code>, one of the time periods, and <code>suffix</code> in
the variable name. The “root” variable without the indicator is whatever
is left. Sometimes, though, this can cause false matches. Here’s an
example I have encountered. My wide data looked like this:</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="right">CaseID</th>
<th align="left">Consent</th>
<th align="right">A1</th>
<th align="right">B1</th>
<th align="right">C1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="left">TRUE</td>
<td align="right">5</td>
<td align="right">4</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="left">TRUE</td>
<td align="right">6</td>
<td align="right">7</td>
<td align="right">8</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="left">TRUE</td>
<td align="right">10</td>
<td align="right">8</td>
<td align="right">6</td>
</tr>
</tbody>
</table>
</div>
<p>My ID variable was called <code>CaseID</code> and the periods — which
were A, B, and C — were labeled at the <em>beginning</em> of the column
names. Following the earlier examples, this will confuse
<code>long_panel()</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">long_panel</span>(wide, <span class="at">begin =</span> <span class="st">&quot;A&quot;</span>, <span class="at">end =</span> <span class="st">&quot;C&quot;</span>, <span class="at">label_location =</span> <span class="st">&quot;beginning&quot;</span>, <span class="at">id =</span> <span class="st">&quot;CaseID&quot;</span>)</span></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">CaseID</th>
<th align="left">wave</th>
<th align="right">1</th>
<th align="left">onsent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">A</td>
<td align="right">5</td>
<td align="left">TRUE</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">B</td>
<td align="right">4</td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">C</td>
<td align="right">3</td>
<td align="left">TRUE</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">A</td>
<td align="right">6</td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">B</td>
<td align="right">7</td>
<td align="left">TRUE</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">C</td>
<td align="right">8</td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">A</td>
<td align="right">10</td>
<td align="left">TRUE</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">B</td>
<td align="right">8</td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">C</td>
<td align="right">6</td>
<td align="left">TRUE</td>
</tr>
</tbody>
</table>
</div>
<p>See what happened? The <code>Consent</code> variable in the wide data
looked just like a constant variable that was measured at time point C.
This isn’t the end of the world, but errors like this can be more
confusing and damaging in other scenarios. Fortunately, I knew more
about the labeling of the time-varying variables than what I told
<code>long_panel()</code>. Yes, there is A/B/C at the beginning with no
prefix/suffix, but also each time-varying item has a <em>number</em>
that comes after A/B/C.</p>
<p><code>long_panel()</code> offers the argument <code>match</code> for
situations like these. This is the regular expression used to match and
then capture the variable name sans time indicator. By default,
<code>match</code> is <code>&quot;.*&quot;</code>, meaning any character any
number of times. To reflect what I know about these data, I change it to
<code>&quot;\\d+.*&quot;</code>, meaning at least one digit following by any
number of other characters.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">long_panel</span>(wide, <span class="at">begin =</span> <span class="st">&quot;A&quot;</span>, <span class="at">end =</span> <span class="st">&quot;C&quot;</span>, <span class="at">label_location =</span> <span class="st">&quot;beginning&quot;</span>, </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>           <span class="at">id =</span> <span class="st">&quot;CaseID&quot;</span>, <span class="at">match =</span> <span class="st">&quot;</span><span class="sc">\\</span><span class="st">d+.*&quot;</span>)</span></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">CaseID</th>
<th align="left">wave</th>
<th align="left">Consent</th>
<th align="right">1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">A</td>
<td align="left">TRUE</td>
<td align="right">5</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">B</td>
<td align="left">TRUE</td>
<td align="right">4</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">C</td>
<td align="left">TRUE</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">A</td>
<td align="left">TRUE</td>
<td align="right">6</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">B</td>
<td align="left">TRUE</td>
<td align="right">7</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">C</td>
<td align="left">TRUE</td>
<td align="right">8</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">A</td>
<td align="left">TRUE</td>
<td align="right">10</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">B</td>
<td align="left">TRUE</td>
<td align="right">8</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">C</td>
<td align="left">TRUE</td>
<td align="right">6</td>
</tr>
</tbody>
</table>
</div>
<p>Now it rightly ignores <code>Consent</code> as a variable that lacks
a time indicator. In general, <code>long_panel()</code> tries to protect
you from having to use or even know how to use regular expressions, but
sometimes there’s no way around it.</p>
</div>
</div>
<div id="from-long-to-wide" class="section level2">
<h2>From long to wide</h2>
<p><code>widen_panel()</code>, as you might expect, does the opposite of
<code>long_panel()</code>. This is generally an easier operation,
thankfully.</p>
<p><code>widen_panel()</code> expects a <code>panel_data</code> object.
If your long data aren’t in that format, it’s easy enough to just pass
it to <code>panel_data()</code>.</p>
<p>To go through an example, let’s take a look at some long data.</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">person</th>
<th align="right">time</th>
<th align="right">Q1</th>
<th align="right">Q2</th>
<th align="left">race</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.0</td>
<td align="right">5.0</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="right">2</td>
<td align="right">1.5</td>
<td align="right">7.5</td>
<td align="left">white</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="right">3</td>
<td align="right">2.0</td>
<td align="right">10.0</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">1</td>
<td align="right">5.0</td>
<td align="right">14.0</td>
<td align="left">black</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="right">2</td>
<td align="right">4.0</td>
<td align="right">10.5</td>
<td align="left">black</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">3</td>
<td align="right">3.0</td>
<td align="right">7.0</td>
<td align="left">black</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">1</td>
<td align="right">15.0</td>
<td align="right">8.0</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="right">2</td>
<td align="right">12.0</td>
<td align="right">12.0</td>
<td align="left">white</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">3</td>
<td align="right">9.0</td>
<td align="right">16.0</td>
<td align="left">white</td>
</tr>
</tbody>
</table>
</div>
<p>Okay, so we have an ID variable (<code>person</code>), wave variable
(<code>time</code>), two time-varying variables (<code>Q1</code> and
<code>Q2</code>), and a time-invariant variable (<code>race</code>). The
only difficulty here conceptually is how to automatically know, without
the domain knowledge about the substantive meaning of these variables,
which ones vary over time and which don’t. This is simply a matter of
<code>widen_panel()</code> checking the variance of each (using the
<code>panelr</code> function <code>are_varying()</code>). Note that in
very wide datasets, or those with many individuals, this can take a
little while to happen.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">widen_panel</span>(long_data, <span class="at">separator =</span> <span class="st">&quot;_&quot;</span>)</span></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">person</th>
<th align="left">race</th>
<th align="right">Q1_1</th>
<th align="right">Q2_1</th>
<th align="right">Q1_2</th>
<th align="right">Q2_2</th>
<th align="right">Q1_3</th>
<th align="right">Q2_3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">white</td>
<td align="right">1</td>
<td align="right">5</td>
<td align="right">1.5</td>
<td align="right">7.5</td>
<td align="right">2</td>
<td align="right">10</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">black</td>
<td align="right">5</td>
<td align="right">14</td>
<td align="right">4.0</td>
<td align="right">10.5</td>
<td align="right">3</td>
<td align="right">7</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">white</td>
<td align="right">15</td>
<td align="right">8</td>
<td align="right">12.0</td>
<td align="right">12.0</td>
<td align="right">9</td>
<td align="right">16</td>
</tr>
</tbody>
</table>
</div>
<p>Pretty much all you need to worry about is how you want to label the
wide data. By default the <code>separator</code> argument is
<code>&quot;_&quot;</code>.</p>
<p>There are only two other arguments. <code>varying</code> lets you
specify which variables in the long data vary over time. This can save
you time compared to having <code>widen_panel()</code> check them all,
but of course requires you to pass those variable names along which can
be more work than it’s worth at times.</p>
<p><code>ignore.attributes</code> deals with the scenario in which you
started with wide data, used <code>long_panel()</code> to convert to
long format, and now want to convert back to wide format.
<code>long_panel()</code> stores information in the data frame about
which variables vary over time so that they don’t have to be checked all
over again. If you’ve made changes or think something went wrong, you
can set <code>ignore.attributes</code> to <code>TRUE</code> to force
those checks all over again.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
