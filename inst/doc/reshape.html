<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Jacob A. Long" />

<meta name="date" content="2020-03-08" />

<title>Reshaping panel data with long_panel() and widen_panel()</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Reshaping panel data with <code>long_panel()</code> and <code>widen_panel()</code></h1>
<h4 class="author">Jacob A. Long</h4>
<h4 class="date">2020-03-08</h4>



<p>One of the initial challenges a data analyst is likely to face with panel data is getting it into a format suitable for analysis. Most regression analyses for panel data require the data to be in <strong>long</strong> format. That means there is a row for each entity (e.g., person) at each time point. If I conducted a 3-wave panel survey of 300 people, each of whom responded to all 3 waves, the long format of these data would have 900 rows (300 respondents x 3 waves).</p>
<p>For example, the following is how long data look, where <code>id</code> is the identifier for each entity, <code>wave</code> is the indicator of the time point, and <code>Q1</code>/<code>Q2</code> are measures repeated at each time point.</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="right">wave</th>
<th align="right">Q1</th>
<th align="right">Q2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.0</td>
<td align="right">5.0</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="right">2</td>
<td align="right">1.5</td>
<td align="right">7.5</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="right">3</td>
<td align="right">2.0</td>
<td align="right">10.0</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">1</td>
<td align="right">5.0</td>
<td align="right">14.0</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="right">2</td>
<td align="right">4.0</td>
<td align="right">10.5</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">3</td>
<td align="right">3.0</td>
<td align="right">7.0</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">1</td>
<td align="right">15.0</td>
<td align="right">8.0</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="right">2</td>
<td align="right">12.0</td>
<td align="right">12.0</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">3</td>
<td align="right">9.0</td>
<td align="right">16.0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Wide</strong> data, on the other hand, have only one row per entity and a separate column for each measure and time point. The same data above in wide format look like this:</p>
<pre><code>Warning: package &#39;Matrix&#39; was built under R version 3.6.2</code></pre>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="right">Q1_W1</th>
<th align="right">Q1_W2</th>
<th align="right">Q1_W3</th>
<th align="right">Q2_W1</th>
<th align="right">Q2_W2</th>
<th align="right">Q2_W3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.5</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">7.5</td>
<td align="right">10</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">5</td>
<td align="right">4.0</td>
<td align="right">3</td>
<td align="right">14</td>
<td align="right">10.5</td>
<td align="right">7</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">15</td>
<td align="right">12.0</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">12.0</td>
<td align="right">16</td>
</tr>
</tbody>
</table>
</div>
<p>Here you differentiate between waves by looking at the column name, which in this case end in &quot;_W&quot; and then the wave indicator. Some analyses prefer the data in this format, like structural equation models.</p>
<p><code>panelr</code> considers the native format of panel data to be <em>long</em> and provides the <code>panel_data</code> class to keep your data tidy in the long format. Of course, sometimes your raw data aren’t in long format and need to be “reshaped” from wide to long. In other cases, you have long format data but need to get it into wide format for some reason or another. <code>panelr</code> provides tools to help with these situations.</p>
<p>There are some other tools, including ones that <code>panelr</code> uses internally, that can manage these situations. However, they tend to be some combination of confusing, inflexible, or too general to be easily used for these purposes by non-experts.</p>
<div id="from-wide-to-long" class="section level2">
<h2>From wide to long</h2>
<p>In my experience, survey contractors (i.e., the people you pay to carry out panel surveys) like to provide the data in wide format. As a general rule, the conversion of data from wide to long is much more difficult than the inverse. When preparing to reshape data from wide to long format, you’ll need to answer some questions relating to how the column/variable names distinguish the variable name from the time indicator:</p>
<ul>
<li>What are the time indicators: numbers, letters, something else?</li>
<li>Are the time labels at the beginning or end of the column name?</li>
<li>Are there prefixes or suffixes surrounding the time indicator (e.g., a name like <code>W1_variable</code> has both prefix (<code>W</code>) and suffix (<code>_</code>)).</li>
</ul>
<p>One key assumption is that variables labeled with a pattern such as <code>Q1_W1</code>, <code>Q1_W2</code>, and so on refer to the <em>same measure</em> at different times. I’ve encountered datasets in which <code>Q1</code> might refer to a different measure at each time point and this is not a problem that can be handled in an automated way.</p>
<p>With that warning out of the way, let’s look at a couple examples.</p>
<div id="wave-indicators-at-the-end-of-variable-names" class="section level3">
<h3>Wave indicators at the end of variable names</h3>
<p>Let’s return to the wide data we looked at earlier.</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="right">Q1_W1</th>
<th align="right">Q1_W2</th>
<th align="right">Q1_W3</th>
<th align="right">Q2_W1</th>
<th align="right">Q2_W2</th>
<th align="right">Q2_W3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.5</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">7.5</td>
<td align="right">10</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">5</td>
<td align="right">4.0</td>
<td align="right">3</td>
<td align="right">14</td>
<td align="right">10.5</td>
<td align="right">7</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">15</td>
<td align="right">12.0</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">12.0</td>
<td align="right">16</td>
</tr>
</tbody>
</table>
</div>
<p>Here we can see that the time indicators are at the <em>end</em> of the variable names (<code>_W1</code>), time indicators of 1, 2, and 3, and a <em>prefix</em> of <code>_W</code>. With that in mind, we can use <code>long_panel()</code> to convert the data to long format.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">long_panel</span>(wide, <span class="dt">prefix =</span> <span class="st">&quot;_W&quot;</span>, <span class="dt">begin =</span> <span class="dv">1</span>, <span class="dt">end =</span> <span class="dv">3</span>, <span class="dt">label_location =</span> <span class="st">&quot;end&quot;</span>)</a></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="right">wave</th>
<th align="right">Q1</th>
<th align="right">Q2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.0</td>
<td align="right">5.0</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="right">2</td>
<td align="right">1.5</td>
<td align="right">7.5</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="right">3</td>
<td align="right">2.0</td>
<td align="right">10.0</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">1</td>
<td align="right">5.0</td>
<td align="right">14.0</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="right">2</td>
<td align="right">4.0</td>
<td align="right">10.5</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">3</td>
<td align="right">3.0</td>
<td align="right">7.0</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">1</td>
<td align="right">15.0</td>
<td align="right">8.0</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="right">2</td>
<td align="right">12.0</td>
<td align="right">12.0</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">3</td>
<td align="right">9.0</td>
<td align="right">16.0</td>
</tr>
</tbody>
</table>
</div>
<p>Perfect! The first argument, <code>w</code>, was the wide data. <code>prefix</code> is self-explanatory. <code>begin</code> and <code>end</code> refer to the range of the time indicators, since they are consecutive. You can instead use <code>periods = c(1, 2, 3)</code> if you prefer. That’s especially true if you have non-consecutive time indicators like a biannual survey that uses the year as an indicator, like <code>periods = c(1990, 1992, 1994)</code>.</p>
</div>
<div id="comparing-with-base-r" class="section level3">
<h3>Comparing with base R</h3>
<p>I should note that base R has a function, <code>reshape()</code> that can work in this situation without making you pull your hair out too much:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">reshape</span>(<span class="kw">as.data.frame</span>(wide), <span class="dt">sep =</span> <span class="st">&quot;_W&quot;</span>, <span class="dt">times =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>), <span class="dt">direction =</span> <span class="st">&quot;long&quot;</span>,</a>
<a class="sourceLine" id="cb3-2" title="2">        <span class="dt">varying =</span> <span class="kw">c</span>(<span class="st">&quot;Q1_W1&quot;</span>, <span class="st">&quot;Q1_W2&quot;</span>, <span class="st">&quot;Q1_W3&quot;</span>, <span class="st">&quot;Q2_W1&quot;</span>, <span class="st">&quot;Q2_W2&quot;</span>, <span class="st">&quot;Q2_W3&quot;</span>))</a></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th></th>
<th align="left">id</th>
<th align="right">time</th>
<th align="right">Q1</th>
<th align="right">Q2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1.1</td>
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.0</td>
<td align="right">5.0</td>
</tr>
<tr class="even">
<td>2.1</td>
<td align="left">2</td>
<td align="right">1</td>
<td align="right">5.0</td>
<td align="right">14.0</td>
</tr>
<tr class="odd">
<td>3.1</td>
<td align="left">3</td>
<td align="right">1</td>
<td align="right">15.0</td>
<td align="right">8.0</td>
</tr>
<tr class="even">
<td>1.2</td>
<td align="left">1</td>
<td align="right">2</td>
<td align="right">1.5</td>
<td align="right">7.5</td>
</tr>
<tr class="odd">
<td>2.2</td>
<td align="left">2</td>
<td align="right">2</td>
<td align="right">4.0</td>
<td align="right">10.5</td>
</tr>
<tr class="even">
<td>3.2</td>
<td align="left">3</td>
<td align="right">2</td>
<td align="right">12.0</td>
<td align="right">12.0</td>
</tr>
<tr class="odd">
<td>1.3</td>
<td align="left">1</td>
<td align="right">3</td>
<td align="right">2.0</td>
<td align="right">10.0</td>
</tr>
<tr class="even">
<td>2.3</td>
<td align="left">2</td>
<td align="right">3</td>
<td align="right">3.0</td>
<td align="right">7.0</td>
</tr>
<tr class="odd">
<td>3.3</td>
<td align="left">3</td>
<td align="right">3</td>
<td align="right">9.0</td>
<td align="right">16.0</td>
</tr>
</tbody>
</table>
</div>
<p>You can see how frustrating that could be if you had many more variables — it wouldn’t be unusual to have hundreds of columns in the wide format, not all of which would be variables that vary over time (e.g., race). Truth be told, <code>long_panel()</code> uses <code>reshape()</code> internally, but only after a lot of processing. Other options include the <code>reshape2</code> and <code>tidyr</code> packages, but they are not purpose-built for the panel setting and therefore can have a learning curve to avoid having data that end up a bit <em>too</em> long.</p>
</div>
<div id="a-more-challenging-example" class="section level3">
<h3>A more challenging example</h3>
<p>Here’s a wide dataset with what is usually a trickier format to handle due to limitations of <code>reshape()</code>.</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="right">WA_Q1</th>
<th align="right">WB_Q1</th>
<th align="right">WC_Q1</th>
<th align="right">WA_Q2</th>
<th align="right">WC_Q2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">1.5</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">10</td>
</tr>
<tr class="even">
<td align="right">5</td>
<td align="right">4.0</td>
<td align="right">3</td>
<td align="right">14</td>
<td align="right">7</td>
</tr>
<tr class="odd">
<td align="right">15</td>
<td align="right">12.0</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">16</td>
</tr>
</tbody>
</table>
</div>
<p>Key characteristics:</p>
<ul>
<li>Wave indicators are at the <em>beginning</em> of the variable names.</li>
<li>The time indicators are <em>letters</em>, from A to C.</li>
<li>There is a prefix (<code>W</code>) and suffix (<code>_</code>).</li>
</ul>
<p>While you don’t have to recognize this to use the function properly, notice that in this case <code>Q2</code> was only measured at times A and C. This can add considerable difficulty to when trying to reshape data “by hand.”</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">long_panel</span>(wide, <span class="dt">prefix =</span> <span class="st">&quot;W&quot;</span>, <span class="dt">suffix =</span> <span class="st">&quot;_&quot;</span>, <span class="dt">label_location =</span> <span class="st">&quot;beginning&quot;</span>,</a>
<a class="sourceLine" id="cb4-2" title="2">           <span class="dt">begin =</span> <span class="st">&quot;A&quot;</span>, <span class="dt">end =</span> <span class="st">&quot;C&quot;</span>)</a></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">wave</th>
<th align="right">Q1</th>
<th align="right">Q2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">A</td>
<td align="right">1.0</td>
<td align="right">5</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">B</td>
<td align="right">1.5</td>
<td align="right">NA</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">C</td>
<td align="right">2.0</td>
<td align="right">10</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">A</td>
<td align="right">5.0</td>
<td align="right">14</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">B</td>
<td align="right">4.0</td>
<td align="right">NA</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">C</td>
<td align="right">3.0</td>
<td align="right">7</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">A</td>
<td align="right">15.0</td>
<td align="right">8</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">B</td>
<td align="right">12.0</td>
<td align="right">NA</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">C</td>
<td align="right">9.0</td>
<td align="right">16</td>
</tr>
</tbody>
</table>
</div>
<p>Just what we were looking for. Note that <code>panel_data</code> objects must have an ordered wave variable, but <code>long_data()</code> understands how to order letters and handles that for you. The missingness in <code>Q2</code> is by design, since it wasn’t measured in wave B.</p>
<p>Another issue that can come up is the treatment of constants — that is, variables that do not change over time. The best wide data should come labeled in a way that makes it clear the constants are constants. For instance, a variable signifying race wouldn’t be called <code>race_W1</code>, but instead just <code>race</code>. <code>long_panel()</code> automatically checks your data for variables that are labeled as if they vary over time but actually do not.</p>
<p>For instance, data that start by looking like this:</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="right">id</th>
<th align="right">Q1_W1</th>
<th align="right">Q1_W2</th>
<th align="right">Q1_W3</th>
<th align="left">race_W1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1.5</td>
<td align="right">2</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">4</td>
<td align="right">3.0</td>
<td align="right">2</td>
<td align="left">black</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">15</td>
<td align="right">12.0</td>
<td align="right">9</td>
<td align="left">white</td>
</tr>
</tbody>
</table>
</div>
<p>Can easily end up shaped like this:</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="right">id</th>
<th align="right">wave</th>
<th align="left">race</th>
<th align="right">Q1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">1</td>
<td align="left">white</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">2</td>
<td align="left">NA</td>
<td align="right">1.5</td>
</tr>
<tr class="odd">
<td align="right">1</td>
<td align="right">3</td>
<td align="left">NA</td>
<td align="right">2.0</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">1</td>
<td align="left">black</td>
<td align="right">4.0</td>
</tr>
<tr class="odd">
<td align="right">2</td>
<td align="right">2</td>
<td align="left">NA</td>
<td align="right">3.0</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">3</td>
<td align="left">NA</td>
<td align="right">2.0</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">1</td>
<td align="left">white</td>
<td align="right">15.0</td>
</tr>
<tr class="even">
<td align="right">3</td>
<td align="right">2</td>
<td align="left">NA</td>
<td align="right">12.0</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">3</td>
<td align="left">NA</td>
<td align="right">9.0</td>
</tr>
</tbody>
</table>
</div>
<p>But obviously just because the wide data marked <code>race</code> with a wave label, that doesn’t mean it was unknown in the other waves. You’ll get the right result with <code>long_panel()</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">long_panel</span>(wide, <span class="dt">prefix =</span> <span class="st">&quot;_W&quot;</span>, <span class="dt">label_location =</span> <span class="st">&quot;end&quot;</span>, <span class="dt">begin =</span> <span class="dv">1</span>, <span class="dt">end =</span> <span class="dv">3</span>)</a></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="right">wave</th>
<th align="right">Q1</th>
<th align="left">race</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.0</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="right">2</td>
<td align="right">1.5</td>
<td align="left">white</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="right">3</td>
<td align="right">2.0</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">1</td>
<td align="right">4.0</td>
<td align="left">black</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="right">2</td>
<td align="right">3.0</td>
<td align="left">black</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">3</td>
<td align="right">2.0</td>
<td align="left">black</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">1</td>
<td align="right">15.0</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="right">2</td>
<td align="right">12.0</td>
<td align="left">white</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">3</td>
<td align="right">9.0</td>
<td align="left">white</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="other-details" class="section level3">
<h3>Other details</h3>
<p>If you have an ID variable in the wide data, you can pass the name of that variable to <code>long_panel()</code> with the <code>id</code> argument, which is <code>&quot;id&quot;</code> by default. If there is no variable with the name you give to <code>id</code>, one will be created. You can also choose the name of the wave variable via <code>wave</code>, which is <code>&quot;wave&quot;</code> by default.</p>
<p>You can also choose not to have the output of <code>long_panel()</code> be a <code>panel_data</code> object by setting <code>as_panel_data</code> to <code>FALSE</code>.</p>
</div>
<div id="advanced-options" class="section level3">
<h3>Advanced options</h3>
<p>There are some other options available to you for tougher cases. For instance, when <code>use.regex</code> is <code>TRUE</code>, the arguments for <code>prefix</code> and <code>suffix</code> are treated as regular expressions for more complicated patterns.</p>
<p>Internally, time-varying variables are detected by the presence of <code>prefix</code>, one of the time periods, and <code>suffix</code> in the variable name. The “root” variable without the indicator is whatever is left. Sometimes, though, this can cause false matches. Here’s an example I have encountered. My wide data looked like this:</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="right">CaseID</th>
<th align="left">Consent</th>
<th align="right">A1</th>
<th align="right">B1</th>
<th align="right">C1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="left">TRUE</td>
<td align="right">5</td>
<td align="right">4</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="left">TRUE</td>
<td align="right">6</td>
<td align="right">7</td>
<td align="right">8</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="left">TRUE</td>
<td align="right">10</td>
<td align="right">8</td>
<td align="right">6</td>
</tr>
</tbody>
</table>
</div>
<p>My ID variable was called <code>CaseID</code> and the periods — which were A, B, and C — were labeled at the <em>beginning</em> of the column names. Following the earlier examples, this will confuse <code>long_panel()</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">long_panel</span>(wide, <span class="dt">begin =</span> <span class="st">&quot;A&quot;</span>, <span class="dt">end =</span> <span class="st">&quot;C&quot;</span>, <span class="dt">label_location =</span> <span class="st">&quot;beginning&quot;</span>, <span class="dt">id =</span> <span class="st">&quot;CaseID&quot;</span>)</a></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">CaseID</th>
<th align="left">wave</th>
<th align="right">1</th>
<th align="left">onsent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">A</td>
<td align="right">5</td>
<td align="left">TRUE</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">B</td>
<td align="right">4</td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">C</td>
<td align="right">3</td>
<td align="left">TRUE</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">A</td>
<td align="right">6</td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">B</td>
<td align="right">7</td>
<td align="left">TRUE</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">C</td>
<td align="right">8</td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">A</td>
<td align="right">10</td>
<td align="left">TRUE</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">B</td>
<td align="right">8</td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">C</td>
<td align="right">6</td>
<td align="left">TRUE</td>
</tr>
</tbody>
</table>
</div>
<p>See what happened? The <code>Consent</code> variable in the wide data looked just like a constant variable that was measured at time point C. This isn’t the end of the world, but errors like this can be more confusing and damaging in other scenarios. Fortunately, I knew more about the labeling of the time-varying variables than what I told <code>long_panel()</code>. Yes, there is A/B/C at the beginning with no prefix/suffix, but also each time-varying item has a <em>number</em> that comes after A/B/C.</p>
<p><code>long_panel()</code> offers the argument <code>match</code> for situations like these. This is the regular expression used to match and then capture the variable name sans time indicator. By default, <code>match</code> is <code>&quot;.*&quot;</code>, meaning any character any number of times. To reflect what I know about these data, I change it to <code>&quot;\\d+.*&quot;</code>, meaning at least one digit following by any number of other characters.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">long_panel</span>(wide, <span class="dt">begin =</span> <span class="st">&quot;A&quot;</span>, <span class="dt">end =</span> <span class="st">&quot;C&quot;</span>, <span class="dt">label_location =</span> <span class="st">&quot;beginning&quot;</span>, </a>
<a class="sourceLine" id="cb7-2" title="2">           <span class="dt">id =</span> <span class="st">&quot;CaseID&quot;</span>, <span class="dt">match =</span> <span class="st">&quot;</span><span class="ch">\\</span><span class="st">d+.*&quot;</span>)</a></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">CaseID</th>
<th align="left">wave</th>
<th align="left">Consent</th>
<th align="right">1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">A</td>
<td align="left">TRUE</td>
<td align="right">5</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">B</td>
<td align="left">TRUE</td>
<td align="right">4</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">C</td>
<td align="left">TRUE</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">A</td>
<td align="left">TRUE</td>
<td align="right">6</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">B</td>
<td align="left">TRUE</td>
<td align="right">7</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">C</td>
<td align="left">TRUE</td>
<td align="right">8</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">A</td>
<td align="left">TRUE</td>
<td align="right">10</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">B</td>
<td align="left">TRUE</td>
<td align="right">8</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">C</td>
<td align="left">TRUE</td>
<td align="right">6</td>
</tr>
</tbody>
</table>
</div>
<p>Now it rightly ignores <code>Consent</code> as a variable that lacks a time indicator. In general, <code>long_panel()</code> tries to protect you from having to use or even know how to use regular expressions, but sometimes there’s no way around it.</p>
</div>
</div>
<div id="from-long-to-wide" class="section level2">
<h2>From long to wide</h2>
<p><code>widen_panel()</code>, as you might expect, does the opposite of <code>long_panel()</code>. This is generally an easier operation, thankfully.</p>
<p><code>widen_panel()</code> expects a <code>panel_data</code> object. If your long data aren’t in that format, it’s easy enough to just pass it to <code>panel_data()</code>.</p>
<p>To go through an example, let’s take a look at some long data.</p>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">person</th>
<th align="right">time</th>
<th align="right">Q1</th>
<th align="right">Q2</th>
<th align="left">race</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">1</td>
<td align="right">1.0</td>
<td align="right">5.0</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="right">2</td>
<td align="right">1.5</td>
<td align="right">7.5</td>
<td align="left">white</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="right">3</td>
<td align="right">2.0</td>
<td align="right">10.0</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">1</td>
<td align="right">5.0</td>
<td align="right">14.0</td>
<td align="left">black</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="right">2</td>
<td align="right">4.0</td>
<td align="right">10.5</td>
<td align="left">black</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">3</td>
<td align="right">3.0</td>
<td align="right">7.0</td>
<td align="left">black</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">1</td>
<td align="right">15.0</td>
<td align="right">8.0</td>
<td align="left">white</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="right">2</td>
<td align="right">12.0</td>
<td align="right">12.0</td>
<td align="left">white</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">3</td>
<td align="right">9.0</td>
<td align="right">16.0</td>
<td align="left">white</td>
</tr>
</tbody>
</table>
</div>
<p>Okay, so we have an ID variable (<code>person</code>), wave variable (<code>time</code>), two time-varying variables (<code>Q1</code> and <code>Q2</code>), and a time-invariant variable (<code>race</code>). The only difficulty here conceptually is how to automatically know, without the domain knowledge about the substantive meaning of these variables, which ones vary over time and which don’t. This is simply a matter of <code>widen_panel()</code> checking the variance of each (using the <code>panelr</code> function <code>are_varying()</code>). Note that in very wide datasets, or those with many individuals, this can take a little while to happen.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">widen_panel</span>(long_data, <span class="dt">separator =</span> <span class="st">&quot;_&quot;</span>)</a></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="left">person</th>
<th align="left">race</th>
<th align="right">Q1_1</th>
<th align="right">Q2_1</th>
<th align="right">Q1_2</th>
<th align="right">Q2_2</th>
<th align="right">Q1_3</th>
<th align="right">Q2_3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">white</td>
<td align="right">1</td>
<td align="right">5</td>
<td align="right">1.5</td>
<td align="right">7.5</td>
<td align="right">2</td>
<td align="right">10</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">black</td>
<td align="right">5</td>
<td align="right">14</td>
<td align="right">4.0</td>
<td align="right">10.5</td>
<td align="right">3</td>
<td align="right">7</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">white</td>
<td align="right">15</td>
<td align="right">8</td>
<td align="right">12.0</td>
<td align="right">12.0</td>
<td align="right">9</td>
<td align="right">16</td>
</tr>
</tbody>
</table>
</div>
<p>Pretty much all you need to worry about is how you want to label the wide data. By default the <code>separator</code> argument is <code>&quot;_&quot;</code>.</p>
<p>There are only two other arguments. <code>varying</code> lets you specify which variables in the long data vary over time. This can save you time compared to having <code>widen_panel()</code> check them all, but of course requires you to pass those variable names along which can be more work than it’s worth at times.</p>
<p><code>ignore.attributes</code> deals with the scenario in which you started with wide data, used <code>long_panel()</code> to convert to long format, and now want to convert back to wide format. <code>long_panel()</code> stores information in the data frame about which variables vary over time so that they don’t have to be checked all over again. If you’ve made changes or think something went wrong, you can set <code>ignore.attributes</code> to <code>TRUE</code> to force those checks all over again.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
